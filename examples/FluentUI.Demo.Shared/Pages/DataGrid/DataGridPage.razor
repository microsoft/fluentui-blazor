@page "/DataGrid"

@using FluentUI.Demo.Shared.Pages.DataGrid.Examples;
@using Microsoft.Fast.Components.FluentUI;

<h1>Data grid</h1>
<p>
    The <code>&lt;FluentDataGrid&gt;</code> component is used to display tabular data. The <code>&lt;FluentDataGridRow&gt;</code>
    and <code>&lt;FluentDataGridCell&gt;</code> components are typically created programmatically by the parent grid but some
    authors may find it useful to create them manually.
</p>
<p>
    <code>&lt;FluentDataGrid&gt;</code> wraps the <code>&lt;fluent-data-grid&gt;</code> element, a web component implementation
    of a data grid leveraging the Fluent  UI design system. Internally <code>&lt;FluentDataGrid&gt;</code> is using the code from
    <a href="https://aspnet.github.io/quickgridsamples">QuickGrid</a> with a few adjustments to parameter names to stay in-line
    with the fluent-data-grid web component (see table below)


    <table title="Parameter name changes">
        <tr>
            <th align="left" style="width: 8rem;">QuickGrid</th>
            <th align="left" style="width: 8rem;">FluentDataGrid</th>
        </tr>
        <tr>
            <td>Items</td>
            <td>RowsData</td>
        </tr>
        <tr>
            <td>ItemsProvider</td>
            <td>RowsDataProvider</td>
        </tr>
        <tr>
            <td>ItemSize</td>
            <td>RowsDataSize</td>
        </tr>
        <tr>
            <td>ItemKey</td>
            <td>RowsDataKey</td>
        </tr>
        <tr>
            <td></td>
            <td></td>
        </tr>
    </table>
</p>

<ApiDocumentation Component="typeof(FluentDataGridCell<>)" GenericLabel="TGridItem" />

<ApiDocumentation Component="typeof(FluentDataGridRow<>)" GenericLabel="TGridItem" />

<ApiDocumentation Component="typeof(FluentDataGrid<>)" GenericLabel="TGridItem" />

<h2>Examples</h2>

<DemoSection Title="Get started" Component="@typeof(DataGridGetStarted)">
    <Description>To begin, add the following code to one of your Blazor page components to render a very simple grid (with sortable columns)</Description>
</DemoSection>

<DemoSection Title="Typical usage" Component="@typeof(DataGridTypical)" CollocatedFiles="@(new[] {"css"})">
    <Description>
        Here is an example of a data grid that uses in-memory data and enables features including pagination, sorting, filtering, column options and column resizing.
    </Description>
</DemoSection>

<DemoSection Title="Remote data" Component="@typeof(DataGridRemoteData)">
    <Description>
        <p>
            If you're using Blazor WebAssembly, it's very common to fetch data from a JSON API on a server. If you want to
            fetch only the data that's needed for the current page/viewport and apply any sorting or filtering rules on the
            server, you can use the <code>ItemsProvider</code> parameter.
        </p>
        <p>
            You can also use <code>ItemsProvider</code> with Blazor Server if it needs to query an external endpoint, or in any
            other case where your requirements aren't covered by an <code>IQueryable</code>.
        </p>
        <p>
            To do this, supply a callback matching the <code>GridItemsProvider&lt;TGridItem&gt;</code> delegate type, where <code>TGridItem</code>
            is the type of data displayed in the grid. Your callback will be given a parameter of type <code>GridItemsProviderRequest&lt;TGridItem&gt;</code>
            which specifies the start index, maximum row count, and sort order of data to return. As well as returning the matching items, you need
            to return a <code>totalItemCount</code> so that paging or virtualization can work.
        </p>
        <p>
            Here is an example of connecting a grid to the public <a href="https://open.fda.gov/apis/food/enforcement/" target="_blank">OpenFDA Food Enforcement database</a>.
        </p>
        <p>
            This gris is usig a 'sticky' header (i.e. the header is always visible when scrolling) and a 'sticky' first column (i.e. the first column is always visible when scrolling).
        </p>
    </Description>
</DemoSection>


<DemoSection Title="Virtualized grid" Component="@typeof(DataGridVirtualize)">
    <Description>
        <p>
            It can be expensive both to fetch and to render large numbers of items. If the amount of data you're
            displaying might be large, you should use either paging or virtualization.
        </p>
        <p>
            Virtualization provides the appearance of continuous scrolling through an arbitrarily-large data set,
            while only needing to fetch and render the rows that are currently in the scroll viewport. This can provide
            excellent performance even when the data set is vast. FluentDataGrid's virtualization feature is built on Blazor's
            built-in <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/virtualization?view=aspnetcore-6.0">Virtualize component</a>, so it shares the
            same capabilities, requirements, and limitations.
        </p>
        <p>
            Enabling virtualization is just a matter of passing <code>Virtualize="true"</code>. For it to work
            properly and reliably, every row rendered must have the same known height. <strong>
                This is handeled by the
                <code>FluentDataGrid</code> code
            </strong>.
        </p>
    </Description>
</DemoSection>

<DemoSection Title="Template columns" Component="@typeof(DataGridTemplateColumns)" CollocatedFiles="@(new[] {"css"})">
    <Description>
        <p>
            <code>TemplateColumn</code> uses arbitrary Razor fragments to supply contents for its cells. It can't
            infer the column's title or sort order automatically.
        </p>
    </Description>
</DemoSection>

@*<DemoSection Title="Template columns 2" Component="@typeof(DataGridTemplateColumns2)"></DemoSection>*@

<DemoSection Title="Dynamic columns" Component="@typeof(DataGridDynamicColumns)">
    <Description>
        <p>
            You can make columns appear conditionally using normal Razor logic such as <code>@@if</code>. Example:
        </p>
    </Description>
</DemoSection>

<DemoSection Title="Custom paging UI" Component="@typeof(DataGridCustomPaging)" CollocatedFiles="@(new[] { "css" })">
    <Description>
        <p>
            You can customize the appearance of <code>Paginator</code> by supplying a <code>SummaryTemplate</code>.
            If you want further customization, you can create your own alternative UI that works with
            <code>PaginationState</code>. Example:
        </p>
    </Description>
</DemoSection>

<DemoSection Title="Manual grid" Component="@typeof(DataGridManual)"></DemoSection>

<DemoSection Title="Template columns (2)" Component="@typeof(DataGridTemplateColumns2)">
    <Description>
        <p>
            <code>TemplateColumn</code> uses arbitrary Razor fragments to supply contents for its cells. It can't
            infer the column's title or sort order automatically.
        </p>
    </Description>
</DemoSection>


<DemoSection Title="Embeded Filters" Component="@typeof(DataGridAllFilterTypes)">
    <Description>
        <p>
            datagrid has its own filter functionality based on column types. for each column type, there is a different filter
            . if column bind to a class property, it can display a list of disitnct values, somthing like excel filter.
            so you can create custom column and implement <code>IFiltrableColumn</code> to add embeded filter functionality
        </p>
    </Description>
</DemoSection>

<DemoSection Title="Inline editor" Component="@typeof(DataGridEditable)">
    <Description>
        <p>
            inline editor is exists with some default editable column.
            <ul>
                <li>
                    <code>DataGridTextboxColumn</code> is and editor for text
                </li>
                <li>
                    <code>DataGridCkeckboxColumn</code> is and editor for bool
                </li>
                <li>
                    <code>DataGridComboboxColumn</code> is and editor for forign keys
                </li>
            </ul>
            so you can add your custom editable column.

            The edit behavior is simiral to Excel, by double click you can start edit and commit edits by "Enter" key down or cancel edit by "Escape" key down.
            datagrid support <code>IEditableObject</code> .so if your model implement this interface, you can create edit sessions and control edit funcitonality 
            by  <code>IEditableObject.BeginEdit()</code> <code>IEditableObject.EndEdit()</code> and <code>IEditableObject.CancelEdit()</code> functions.

            datagrid support validation attributes on model, so before each commit, datagrid validate data and commit edit if it is valid.

            on the other hand, datagrid raises events for each action on edit process.
            <ul>
                <li>
                    <code>CellBeginEdit</code> : when a cell begin edit, or get focuse on edit mode.you can cancel begin edit by setting "Cancel" property of "DataGridBeginEditEventArgs"
                </li>
                <li>
                    <code>CellEditEnding</code> : user going to end the edit or cell lost focuse on edit mode. you can cancel edit ending by setting "Cancel" property of "DataGridCellEditEndingEventArgs"
                </li>
                <li>
                    <code>CellEditEnded</code> : cell edit ended
                </li>
                <li>
                    <code>RowEditEnding</code> : user going to end edit of row. you can cancel edit ending by setting "Cancel" property of "DataGridRowEditEndingEventArgs"
                </li>
                <li>
                    <code>RowEditEnded</code> : row edit ended
                </li>
                <li>
                    <code>RowDelete</code> : user pressed "Delete" key, when there is no row on edit mode
                </li>
            </ul>

            in edit mode, "Tab" key can set focuse to the next column

        </p>
    </Description>
</DemoSection>