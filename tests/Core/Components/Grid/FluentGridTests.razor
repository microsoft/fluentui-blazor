@using Xunit;
@inherits TestContext
@code
{
    public FluentGridTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddSingleton<LibraryConfiguration>();
    }

    [Fact]
    public void FluentGrid_Default()
    {
        // Arrange && Act
        var cut = Render(@<FluentGrid>My content</FluentGrid>);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentGrid_SpacingJustify()
    {
        // Arrange && Act
        var cut = Render(@<FluentGrid Spacing="5" Justify="JustifyContent.Center">My content</FluentGrid>);

        //Assert
        cut.Verify();
    }

    [Fact]
    public void FluentGrid_Items_Default()
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem Xs="6" Md="6">Cell 1</FluentGridItem>
        <FluentGridItem Xs="6" Md="6">Cell 2</FluentGridItem>
    </FluentGrid>);

        //Assert
        cut.Verify();
    }

    [Fact]
    public void FluentGrid_Items_AllBreakpoints()
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem Xs="1" Sm="2" Md="3" Lg="4" Xl="5" Xxl="6">My cell</FluentGridItem>
    </FluentGrid>);

        //Assert
        cut.Verify();
    }

    [Fact]
    public void FluentGrid_Items_JustifyGap()
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem Xs="1" Justify="JustifyContent.Center" Gap="10px">My cell</FluentGridItem>
    </FluentGrid>);

        //Assert
        cut.Verify();
    }

    [Fact]
    public void FluentGrid_Items_NoBreapoint()
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem Style="min-width: 200px;">My cell</FluentGridItem>
    </FluentGrid>);

        //Assert
        cut.Verify();
    }

    [Theory]
    [InlineData(GridItemHidden.Xs, "xs")]
    [InlineData(GridItemHidden.Sm, "sm")]
    [InlineData(GridItemHidden.Md, "md")]
    [InlineData(GridItemHidden.Lg, "lg")]
    [InlineData(GridItemHidden.Xl, "xl")]
    [InlineData(GridItemHidden.Xxl, "xxl")]
    [InlineData(GridItemHidden.SmAndDown, "xs sm")]
    [InlineData(GridItemHidden.MdAndDown, "xs sm md")]
    [InlineData(GridItemHidden.LgAndDown, "xs sm md lg")]
    [InlineData(GridItemHidden.XlAndDown, "xs sm md lg xl")]
    [InlineData(GridItemHidden.XxlAndDown, "xs sm md lg xl xxl")]
    [InlineData(GridItemHidden.SmAndUp, "sm md lg xl xxl")]
    [InlineData(GridItemHidden.MdAndUp, "md lg xl xxl")]
    [InlineData(GridItemHidden.LgAndUp, "lg xl xxl")]
    [InlineData(GridItemHidden.XlAndUp, "xl xxl")]
    public void FluentGrid_Hidden(GridItemHidden hidden, string assert)
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem HiddenWhen="@hidden">My cell</FluentGridItem>
    </FluentGrid>
    );

        var hiddenAttribute = cut.Find("div[hidden-when]").GetAttribute("hidden-when") ?? string.Empty;

        // Assert
        Assert.Equal(assert, hiddenAttribute);
    }

    [Theory]
    [InlineData(GridItemHidden.XsAndDown, "xs")]
    [InlineData(GridItemHidden.XsAndUp, "xs sm md lg xl xxl")]
    [InlineData(GridItemHidden.XxlAndUp, "xxl")]
    public void FluentGrid_HiddenExtra(GridItemHidden hidden, string assert)
    {
        FluentGrid_Hidden(hidden, assert);
    }

    [Theory]
    [InlineData("xs", GridItemHidden.XxlAndDown)]
    [InlineData("sm", GridItemHidden.XsAndUp)]
    [InlineData("md", GridItemHidden.XsAndUp)]
    [InlineData("lg", GridItemHidden.XsAndUp)]
    [InlineData("xl", GridItemHidden.XsAndUp)]
    [InlineData("xxl", GridItemHidden.XsAndUp)]
    public async Task FluentGrid_Grid_AdaptiveRendering(string size, GridItemHidden hiddenWhen)
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid AdaptiveRendering="true">
        <FluentGridItem HiddenWhen="@hiddenWhen">Cell 1</FluentGridItem>
        <FluentGridItem HiddenWhen="GridItemHidden.XxlAndUp">Cell 2</FluentGridItem>
    </FluentGrid>
    );

        // Simulate screen size Medium
        var grid = cut.FindComponent<FluentGrid>();
        await grid.Instance.FluentGrid_MediaChangedAsync(size);
        grid.Render();

        //Assert
        Assert.DoesNotContain("Cell 1", cut.Markup);
    }

    [Theory]
    [InlineData(GridItemSize.Xs, GridItemHidden.Xs)]
    [InlineData(GridItemSize.Sm, GridItemHidden.Sm)]
    [InlineData(GridItemSize.Md, GridItemHidden.Md)]
    [InlineData(GridItemSize.Lg, GridItemHidden.Lg)]
    [InlineData(GridItemSize.Xl, GridItemHidden.Xl)]
    [InlineData(GridItemSize.Xxl, GridItemHidden.Xxl)]
    [InlineData(GridItemSize.Xs | GridItemSize.Xxl, GridItemHidden.None)]
    public void FluentGrid_ConvertToHidden(GridItemSize size, GridItemHidden expected)
    {
        Assert.Equal(expected, FluentGridItem.ConvertToHidden(size));
    }

    [Fact]
    public async Task FluentGrid_GridItem_AdaptiveRendering()
    {
        // Arrange && Act
        var cut = Render(
    @<FluentGrid>
        <FluentGridItem AdaptiveRendering="true" HiddenWhen="GridItemHidden.XsAndUp">Cell 1</FluentGridItem>
        <FluentGridItem HiddenWhen="GridItemHidden.XxlAndUp">Cell 2</FluentGridItem>
    </FluentGrid>
    );

        // Simulate screen size Medium
        var grid = cut.FindComponent<FluentGrid>();
        await grid.Instance.FluentGrid_MediaChangedAsync("md");
        grid.Render();

        //Assert
        Assert.DoesNotContain("Cell 1", cut.Markup);
    }

    [Fact]
    public async Task FluentGrid_OnBreakpointEnterAsync()
    {
        GridItemSize? size;

        // Arrange && Act
        var cut = Render(@<FluentGrid OnBreakpointEnter="@(e => size = e)">My content</FluentGrid>);
        size = null;

        // Act
        await cut.FindComponent<FluentGrid>().Instance.FluentGrid_MediaChangedAsync("xs");

        //Assert
        Assert.Equal(GridItemSize.Xs, size);
    }

}
