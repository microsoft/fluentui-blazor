@using Microsoft.FluentUI.AspNetCore.Components.Extensions
@using Microsoft.FluentUI.AspNetCore.Components.Utilities
@using Microsoft.AspNetCore.Components.Forms
@using System.Linq.Expressions
@using Bunit
@using Xunit;
@inherits FluentUITestContext
@code
{
    public FluentFieldTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentField_Default()
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" Message="My message">Field content</FluentField>);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentField_DefaultTemplate()
    {
        // Arrange & Act
        var cut = Render(
    @<FluentField>
        <LabelTemplate>
            My <b>label</b>
        </LabelTemplate>
        <ChildContent>
            Field content
        </ChildContent>
        <MessageTemplate>
            My <i>message</i>
        </MessageTemplate>
    </FluentField>);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentField_MessageIcon()
    {
        // Arrange & Act
        var cut = Render(@<FluentField Message="My message" MessageIcon="@Samples.Icons.Info" MessageCondition="@FluentFieldCondition.Always">Field content</FluentField>);

        // Assert
        cut.Verify();
    }

    [Theory]
    [InlineData(MessageState.Success)]
    [InlineData(MessageState.Warning)]
    [InlineData(MessageState.Error)]
    [InlineData(null)]
    [InlineData((MessageState)99)]
    public void FluentField_MessageState(MessageState? value)
    {
        // Arrange & Act
        var cut = Render(@<FluentField MessageState="@value">Field content</FluentField>);

        // Assert
        cut.Verify(suffix: value is null ? "" : value.ToString()!.ToLower());
    }

    [Theory]
    [InlineData(LabelPosition.Above)]
    [InlineData(LabelPosition.After)]
    [InlineData(LabelPosition.Before)]
    public void FluentField_LabelPosition(LabelPosition position)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" LabelPosition="@position">Field content</FluentField>);

        // Assert
        var attribute = cut.Find("fluent-field").GetAttribute("label-position");
        var expected = position.ToAttributeValue();

        Assert.Equal(expected, attribute);
    }

    [Theory]
    [InlineData(LabelPosition.Above, null, "")]
    [InlineData(LabelPosition.After, null, "")]
    [InlineData(LabelPosition.Before, null, "")]
    [InlineData(LabelPosition.Above, "100px", "")]
    [InlineData(LabelPosition.After, "100px", "100px")]
    [InlineData(LabelPosition.Before, "100px", "100px")]
    public void FluentField_LabelWidth(LabelPosition position, string? width, string? expectedWidthAttribute)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" LabelWidth="@width" LabelPosition="@position">Field content</FluentField>);

        // Assert
        var attribute = cut.Find("label").ComputeCurrentStyle().GetPropertyValue("width");

        Assert.Equal(expectedWidthAttribute, attribute);
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void FluentField_Required(bool required)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" Message="My message" Required="@required">Field content</FluentField>);

        // Assert
        var hasAttribute = cut.Find("label").HasAttribute("required");

        Assert.Equal(required, hasAttribute);
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void FluentField_Disabled(bool disabled)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" Message="My message" Disabled="@disabled">Field content</FluentField>);

        // Assert
        var hasAttribute = cut.Find("label").HasAttribute("disabled");

        Assert.Equal(disabled, hasAttribute);
    }

    [Theory]
    [InlineData(null, null)]
    [InlineData(null, "id-input")]
    [InlineData("", "id-input")]
    [InlineData("id1", "id-input")]
    [InlineData("id1", null)]
    [InlineData("id1", "")]
    public void FluentField_ForId(string? fieldId, string? forId)
    {
        var hasInputId = !string.IsNullOrEmpty(forId);

        if (string.IsNullOrEmpty(fieldId))
        {
            fieldId = "myId";
        }

        // Arrange & Act
        var cut = Render(@<FluentField Id="@fieldId" Label="My label" ForId="@forId">Field content</FluentField>);
        var labelIdAttr = cut.Find("label").GetAttribute("id");
        var labelForAttr = cut.Find("label").GetAttribute("for");
        var inputIdAttr = cut.Find("div").GetAttribute("id");

        // Id
        var id = $"{(string.IsNullOrEmpty(fieldId) ? "myId" : fieldId)}";
        var labelId = $"{id}-label";
        var inputId = hasInputId ? forId : $"{id}-input";

        // Assert
        Assert.Equal(labelId, labelIdAttr);
        Assert.Equal(inputId, labelForAttr);
        Assert.Equal(inputId, inputIdAttr);
    }

    [Fact]
    public void FluentField_InvalidSlot()
    {
        // Call GetId for a standalone FluentField
        var field1 = new FluentField(LibraryConfiguration.Empty);
        Assert.Throws<ArgumentException>(() =>
        {
            field1.GetId("Unknown");
        });

        // Call GetId for a mixed FluentField
#pragma warning disable BL0005  // Component parameter should not be set outside of its component.
        var field2 = new FluentField(LibraryConfiguration.Empty)
        {
                InputComponent = new FluentFieldParameterCollectorTests.MockFluentField()
        };
        Assert.Throws<ArgumentException>(() =>
        {
            field2.GetId("Unknown");
        });
#pragma warning restore BL0005
    }

    [Theory]
    [InlineData(FieldSize.Small)]
    [InlineData(FieldSize.Medium)]
    [InlineData(FieldSize.Large)]
    [InlineData(null)]
    [InlineData((FieldSize)99)]

    public void FluentField_Size(FieldSize? value)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Label="My label" Size="@value">Field content</FluentField>);

        // Assert
        cut.Verify(suffix: value is null ? "" : value.ToString()!.ToLower());


    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void FluentField_IncludeInputSlot(bool withInputSlot)
    {
        // Arrange & Act
        var cut = Render(@<FluentField Id="MyField" IncludeInputSlot="@withInputSlot">Field content</FluentField>);

        // Act
        var hasContent = cut.Markup.Contains(">Field content<");
        var hasSlot = cut.Markup.Contains("<div slot=\"input\" id=\"MyField-input\"");

        // Assert
        Assert.True(hasContent);
        Assert.Equal(withInputSlot, hasSlot);
    }

    [Fact]
    public void FluentField_HideFluentField()
    {
        // Arrange & Act
        var cut = Render(@<CascadingValue Value="true" Name="HideFluentField"><FluentField>Field content</FluentField></CascadingValue>);

        // Assert
        Assert.Equal("Field content", cut.Markup);
    }

    [Fact]
    public void FluentField_ValidationMessages_DisplaysErrors()
    {
        // Arrange
        var model = new TestModel { Name = "" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        messageStore.Add(editContext.Field(nameof(TestModel.Name)), "Name is required");

        // Act
        var cut = Render(
            @<EditForm EditContext="editContext">
                <FluentField For="@(() => model.Name)">Field content</FluentField>
            </EditForm>);

        // Assert
        Assert.Contains("Name is required", cut.Markup);
    }

    [Fact]
    public void FluentField_ValidationMessages_ExcludesMessageParameter()
    {
        // Arrange
        var model = new TestModel { Name = "" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        messageStore.Add(editContext.Field(nameof(TestModel.Name)), "Custom Message");

        // Act
        var cut = Render(
            @<EditForm EditContext="editContext">
                <FluentField For="@(() => model.Name)" Message="Custom Message" MessageCondition="@FluentFieldCondition.Never">Field content</FluentField>
            </EditForm>);

        // Assert
        // "Custom Message" should be excluded because it matches the Message parameter
        Assert.DoesNotContain("Custom Message", cut.Markup);
    }

    [Fact]
    public void FluentField_ValidationMessages_WithCondition()
    {
        // Arrange
        var model = new TestModel { Name = "" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        messageStore.Add(editContext.Field(nameof(TestModel.Name)), "Validation Error");

        // Act
        var cut = Render(
            @<EditForm EditContext="editContext">
                <FluentField For="@(() => model.Name)" Message="Condition Met" MessageCondition="@FluentFieldCondition.Always">Field content</FluentField>
            </EditForm>);

        // Assert
        Assert.Contains("Validation Error", cut.Markup);
        Assert.Contains("Condition Met", cut.Markup);
    }

    private class TestModel
    {
        public string? Name { get; set; }
        public string? Description { get; set; }
    }

    private class MockFluentField : IFluentField
    {
        public LambdaExpression? ValueExpression { get; set; }
        public bool FocusLost { get; set; }
        public string? Label { get; set; }
        public RenderFragment? LabelTemplate { get; set; }
        public LabelPosition? LabelPosition { get; set; }
        public string? LabelWidth { get; set; }
        public bool? Required { get; set; }
        public bool? Disabled { get; set; }
        public string? Message { get; set; }
        public Icon? MessageIcon { get; set; }
        public RenderFragment? MessageTemplate { get; set; }
        public Func<IFluentField, bool>? MessageCondition { get; set; }
        public MessageState? MessageState { get; set; }
    }

    [Fact]
    public void FluentField_Field_Parameter_Takes_Precedence()
    {
        // Arrange
        var model = new TestModel { Name = "Name", Description = "Desc" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        
        var nameField = editContext.Field(nameof(TestModel.Name));
        var descField = editContext.Field(nameof(TestModel.Description));
        
        messageStore.Add(nameField, "Name error");
        messageStore.Add(descField, "Description error");

        // Act
        var cut = Render(
            @<EditForm EditContext="editContext">
                <FluentField For="@(() => model.Name)" Field="@descField">Field content</FluentField>
            </EditForm>);

        // Assert
        Assert.Contains("Description error", cut.Markup);
        Assert.DoesNotContain("Name error", cut.Markup);
    }

    [Fact]
    public void FluentField_Uses_InputComponent_ValueExpression()
    {
        // Arrange
        var model = new TestModel { Name = "Name" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        var nameField = editContext.Field(nameof(TestModel.Name));
        messageStore.Add(nameField, "Name error");

        var inputComponent = new MockFluentField 
        { 
            ValueExpression = (Expression<Func<string?>>)(() => model.Name) 
        };

        // Act
        var cut = Render<FluentField>(parameters => parameters
            .AddCascadingValue(editContext)
            .Add(p => p.InputComponent, inputComponent)
        );

        // Assert
        Assert.Contains("Name error", cut.Markup);
    }

    [Fact]
    public void FluentField_Swapping_For_Updates_Identifier()
    {
        // Arrange
        var model = new TestModel { Name = "", Description = "" };
        var editContext = new EditContext(model);
        var messageStore = new ValidationMessageStore(editContext);
        messageStore.Add(editContext.Field(nameof(TestModel.Name)), "Name Error");
        messageStore.Add(editContext.Field(nameof(TestModel.Description)), "Desc Error");

        // Act & Assert 1
        var cut1 = Render<FluentField>(parameters => parameters
            .AddCascadingValue(editContext)
            .Add(p => p.For, (Expression<Func<string?>>)(() => model.Name))
        );

        Assert.Contains("Name Error", cut1.Markup);
        Assert.DoesNotContain("Desc Error", cut1.Markup);

        // Act & Assert 2
        var cut2 = Render<FluentField>(parameters => parameters
            .AddCascadingValue(editContext)
            .Add(p => p.For, (Expression<Func<string?>>)(() => model.Description))
        );

        Assert.Contains("Desc Error", cut2.Markup);
        Assert.DoesNotContain("Name Error", cut2.Markup);
    }

    [Fact]
    public void FluentField_IFluentField_ValueExpression_Returns_For()
    {
        // Arrange
        var model = new TestModel { Name = "test" };
        Expression<Func<string?>> expression = () => model.Name;
        var cut = Render<FluentField>(parameters => parameters.Add(p => p.For, expression));
        var field = cut.Instance;
        IFluentField ifield = field;

        // Act & Assert
        Assert.Equal(expression, ifield.ValueExpression);
    }
}
