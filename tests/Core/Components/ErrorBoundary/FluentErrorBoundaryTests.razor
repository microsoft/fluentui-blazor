@using Microsoft.FluentUI.AspNetCore.Components.Tests.Components.ErrorBoundary.Components
@using Xunit;
@inherits FluentUITestContext
@code
{
    public FluentErrorBoundaryTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentErrorBoundary_WithoutException()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary>
            <ChildContent>
                <ThrowingExceptionComponent Throw="false">My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert
        cut.MarkupMatches("<div>My content</div>");
    }

    [Fact]
    public void FluentErrorBoundary_WithException()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary MaximumErrorCount="10">
            <ChildContent>
                <ThrowingExceptionComponent Throw="true">My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentErrorBoundary_ErrorHeader()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary>
            <ChildContent>
                <ThrowingExceptionComponent>My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorHeader>My Header</ErrorHeader>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert
        Assert.Contains("<div slot=\"title\" style=\"display: flex; column-gap: 4px; align-items: center;\">My Header</div>", cut.Markup);
    }

    [Fact]
    public void FluentErrorBoundary_HideChildContentOnError_True()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary HideChildContentOnError="true">
            <ChildContent>
                <ThrowingExceptionComponent>My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert
        var hasContent = cut.Markup.Contains("My content");
        Assert.False(hasContent);
    }

    [Fact]
    public void FluentErrorBoundary_HideChildContentOnError_False()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary HideChildContentOnError="false">
            <ChildContent>
                <ThrowingExceptionComponent>My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        cut.FindComponent<FluentErrorBoundary>().Render();

        // Assert
        var hasContent = cut.Markup.Contains("My content");
        Assert.True(hasContent);

        // "error" attribute should be present
        Assert.Contains("<div error>", cut.Markup);
    }

    [Theory]
    [InlineData(ErrorBoundaryDetails.None, @"An unhandled error has occurred. Please, contact your IT support.")]
    [InlineData(ErrorBoundaryDetails.ErrorMessage, @"Test exception")]
    [InlineData(ErrorBoundaryDetails.ErrorStack, @"ThrowingExceptionComponent.razor")]
    [InlineData((ErrorBoundaryDetails)999, @"An unhandled error has occurred. Please, contact your IT support.")]
    public void FluentErrorBoundary_DisplayErrorDetails_ErrorStack(ErrorBoundaryDetails errorDetails, string expectedHTML)
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary DisplayErrorDetails="@errorDetails">
            <ThrowingExceptionComponent>My content</ThrowingExceptionComponent>
        </FluentErrorBoundary>);

        // Assert
        Assert.Contains(expectedHTML, cut.Markup);
    }

    [Fact]
    public async Task FluentErrorBoundary_Recover()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary>
            <ChildContent>
                <ThrowingExceptionComponent Throw="true">My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert initially in error
        Assert.Contains("My Error", cut.Markup);

        // Act
        await cut.InvokeAsync(() => cut.FindComponent<FluentErrorBoundary>().Instance.Recover());
        cut.Render();

        // Assert: back to normal (because ERROR_ALREADY_OCCURED prevents second throw)
        Assert.Contains("My content", cut.Markup);
    }

    [Theory]
    [InlineData("open", true)]
    [InlineData("closed", false)]
    public async Task FluentErrorBoundary_OnToggleAsync(string newState, bool remainsInError)
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary>
            <ThrowingExceptionComponent>My content</ThrowingExceptionComponent>
        </FluentErrorBoundary>);

        // Act
        await cut.InvokeAsync(() => cut.FindComponent<FluentErrorBoundary>().Instance.OnToggleAsync(new()
        {
            NewState = newState,
        }));
        cut.Render();

        // Assert
        if (remainsInError)
        {
            Assert.DoesNotContain("My content", cut.Markup);
        }
        else
        {
            Assert.Contains("My content", cut.Markup);
        }
    }

    [Fact]
    public void FluentErrorBoundary_OnCloseRedirectUrl()
    {
        // Arrange
        var cut = Render(@<FluentErrorBoundary OnCloseRedirectUrl="/">
            <ChildContent>
                <ThrowingExceptionComponent Throw="true">My content</ThrowingExceptionComponent>
            </ChildContent>
            <ErrorContent>My Error</ErrorContent>
        </FluentErrorBoundary>);

        // Assert
        Assert.Contains("window.location.href='/'", cut.Markup);
    }
}
