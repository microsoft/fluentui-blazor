@using Xunit;
@inherits TestContext
@code
{
    // A timeout can be set when you open a dialog box and do not close it.
    private const int TEST_TIMEOUT = 3000;

    public FluentDialogTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();

        DialogService = Services.GetRequiredService<IDialogService>();
        DialogProvider = RenderComponent<FluentDialogProvider>();
    }

    /// <summary>
    /// Gets the dialog service.
    /// </summary>
    public IDialogService DialogService { get; }

    /// <summary>
    /// Gets the dialog provider.
    /// </summary>
    public IRenderedComponent<FluentDialogProvider> DialogProvider { get; }

    [Fact(Timeout = TEST_TIMEOUT)]
    public async Task FluentDialog_Render()
    {
        // Arrange
        var renderOptions = new Templates.DialogRenderOptions();

        // Act
        var dialogTask = DialogService.ShowDialogAsync<Templates.DialogRender>(options =>
               {
                   options.Parameters.Add(nameof(Templates.DialogRender.Options), renderOptions);
                   options.Parameters.Add(nameof(Templates.DialogRender.Name), "John");
               });

        // Don't wait for the dialog to be closed
        await Task.CompletedTask;

        // Assert
        DialogProvider.Verify();
    }

    [Fact(Timeout = TEST_TIMEOUT)]
    public async Task FluentDialog_OpenClose()
    {
        // Arrange
        var renderOptions = new Templates.DialogRenderOptions()
            {
                AutoClose = true,
            };

        // Act
        var dialogTask = DialogService.ShowDialogAsync<Templates.DialogRender>(options =>
                {
                    options.Parameters.Add(nameof(Templates.DialogRender.Options), renderOptions);
                    options.Parameters.Add(nameof(Templates.DialogRender.Name), "John");
                });

        // Wait for the dialog to be closed (auto-closed)
        var result = await dialogTask;

        // Assert
        Assert.Equal(1, renderOptions.OnInitializedCount);
        Assert.Equal(1, renderOptions.OnParametersSetCount);
    }

    [Theory(Timeout = TEST_TIMEOUT)]
    [ClassData(typeof(Data.ShortcutsData))]
    public async Task FluentDialog_ShortcutToClose(Data.ShortcutsDataItem item)
    {
        // Arrange
        var renderOptions = new Templates.DialogRenderOptions();
        
        // Act
        var dialogTask = DialogService.ShowDialogAsync<Templates.DialogRender>(options =>
               {
                   options.Parameters.Add(nameof(Templates.DialogRender.Options), renderOptions);
                   options.Parameters.Add(nameof(Templates.DialogRender.Name), "John");

                   options.Footer.PrimaryAction.Label = "OK";
                   if (!string.IsNullOrEmpty(item.PrimaryShortcut))
                   {
                       options.Footer.PrimaryAction.ShortCut = item.PrimaryShortcut;
                   }

                   options.Footer.SecondaryAction.Label = "Cancel";
                   if (!string.IsNullOrEmpty(item.SecondaryShortcut))
                   {
                       options.Footer.SecondaryAction.ShortCut = item.SecondaryShortcut;
                   }
               });

        // Send a shortcut to close the dialog
        DialogProvider.Find("fluent-dialog").KeyDown(item.Pressed);

        var result = await dialogTask;

        // Assert
        Assert.Equal(item.ExpectedCancelled, result.Cancelled);
    }
}
