@using System.Reflection
@using System.Linq
@using Bunit.Rendering
@using Bunit
@using Microsoft.FluentUI.AspNetCore.Components.Utilities
@using Microsoft.AspNetCore.Components.Web
@using Xunit;
@using Microsoft.FluentUI.AspNetCore.Components.Tests.Samples;
@inherits FluentUITestContext

@code
{
    public FluentPullToRefreshTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentPullToRefresh_Default()
    {
        // Arrange && Act
        var cut = Render(@<FluentPullToRefresh>Content that can be refreshed</FluentPullToRefresh>);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentPullToRefresh_Default_RendersTipAndContent()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Style, "width:100%;")
            .AddUnmatched("data-test", "pull-root")
            .Add(p => p.ChildContent, builder =>
            {
                builder.OpenElement(0, "div");
                builder.AddAttribute(1, "class", "content");
                builder.AddContent(2, "Hello");
                builder.CloseElement();
            }));

        // Assert
        var root = cut.Find("div.fluent-pull-container");
        Assert.Contains("fluent-pull-container", root.GetAttribute("class"));
        Assert.Equal("pull-root", root.GetAttribute("data-test"));
        var tip = cut.Find("[part='tip']");
        Assert.Equal("down", tip.GetAttribute("direction"));
        Assert.Contains("--fluent-pull-refresh-head-height: 32px", tip.GetAttribute("style"));
        Assert.Equal("Hello", cut.Find(".content").TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_DirectionUp_RendersTipAfterContent()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Direction, PullDirection.Up)
            .Add(p => p.ChildContent, builder =>
            {
                builder.OpenElement(0, "div");
                builder.AddAttribute(1, "class", "content");
                builder.AddContent(2, "Content");
                builder.CloseElement();
            }));

        // Assert
        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Equal(2, wrapper.Children.Length);
        Assert.Equal("content", wrapper.Children[0].ClassName);
        Assert.Equal("up", wrapper.Children[1].GetAttribute("direction"));
    }

    [Fact]
    public void FluentPullToRefresh_ShowStaticTipFalse_HidesTip()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.ShowStaticTip, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        // Assert
        Assert.Empty(cut.FindAll("[part='tip']"));
    }

    [Fact]
    public void FluentPullToRefresh_CustomPullingTemplate_Rendered()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.PullingTemplate, builder =>
            {
                builder.OpenElement(0, "span");
                builder.AddAttribute(1, "class", "custom-tip");
                builder.AddContent(2, "Custom tip");
                builder.CloseElement();
            })
            .Add(p => p.ChildContent, builder => builder.AddContent(3, "Content")));

        // Assert
        var tip = cut.Find("[part='tip'] .custom-tip");
        Assert.Equal("Custom tip", tip.TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_CustomReleaseTemplate_Rendered()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content"))
            .Add(p => p.ReleaseTemplate, SpanTemplate("release-tip", "Release it")));

        SetPullStatus(cut, PullStatus.WaitingForRelease);

        // Assert
        var tip = cut.Find("[part='tip'] .release-tip");
        Assert.Equal("Release it", tip.TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_CustomLoadingTemplate_Rendered()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content"))
            .Add(p => p.LoadingTemplate, SpanTemplate("loading-tip", "Loading")));

        SetPullStatus(cut, PullStatus.Loading);

        // Assert
        var tip = cut.Find("[part='tip'] .loading-tip");
        Assert.Equal("Loading", tip.TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_CustomCompletedTemplate_Rendered()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content"))
            .Add(p => p.CompletedTemplate, SpanTemplate("completed-tip", "Done")));

        SetPullStatus(cut, PullStatus.Completed);

        // Assert
        var tip = cut.Find("[part='tip'] .completed-tip");
        Assert.Equal("Done", tip.TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_CustomNoDataTemplate_Rendered()
    {
        // Arrange
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content"))
            .Add(p => p.NoDataTemplate, SpanTemplate("nodata-tip", "No data")));

        SetPullStatus(cut, PullStatus.NoData);

        // Assert
        var tip = cut.Find("[part='tip'] .nodata-tip");
        Assert.Equal("No data", tip.TextContent.Trim());
    }

    [Fact]
    public void FluentPullToRefresh_ParameterValues_AreSet()
    {
        // Arrange
        Func<Task<bool>> refresh = () => Task.FromResult(true);
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Direction, PullDirection.Up)
            .Add(p => p.Disabled, true)
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ShowStaticTip, false)
            .Add(p => p.DragDistance, 64)
            .Add(p => p.TipHeight, 48)
            .Add(p => p.StatusUpdateMessageTimeout, 1200)
            .Add(p => p.DragThreshold, 12)
            .Add(p => p.OnRefreshAsync, refresh)
            .AddUnmatched("class", "extra")
            .AddUnmatched("style", "height: 50px;")
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Child")));

        // Assert
        var instance = cut.Instance;
        Assert.Equal(PullDirection.Up, instance.Direction);
        Assert.True(instance.Disabled);
        Assert.False(instance.EmulateTouch);
        Assert.False(instance.ShowStaticTip);
        Assert.Equal(64, instance.DragDistance);
        Assert.Equal(48, instance.TipHeight);
        Assert.Equal(1200, instance.StatusUpdateMessageTimeout);
        Assert.Equal(12, instance.DragThreshold);
        Assert.Equal(refresh, instance.OnRefreshAsync);
        var root = cut.Find("div.fluent-pull-container");
        Assert.Contains("extra", root.GetAttribute("class"));
        Assert.Contains("height: 50px", root.GetAttribute("style"));
    }

    [Fact]
    public void FluentPullToRefresh_DefaultPullingTemplate_RendersIcon()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var tip = cut.Find("[part='tip']");
        Assert.NotNull(tip.QuerySelector("svg"));
    }

    [Fact]
    public void FluentPullToRefresh_DefaultLoadingTemplate_RendersSpinner()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        SetPullStatus(cut, PullStatus.Loading);

        var tip = cut.Find("[part='tip']");
        Assert.NotNull(tip.QuerySelector("fluent-spinner"));
    }

    [Fact]
    public void FluentPullToRefresh_DefaultCompletedTemplateRendersIcon()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        SetPullStatus(cut, PullStatus.Completed);

        var tip = cut.Find("[part='tip']");
        Assert.NotNull(tip.QuerySelector("svg"));
    }

    [Fact]
    public void FluentPullToRefresh_DefaultNoDataTemplate_RendersMessage()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        SetPullStatus(cut, PullStatus.NoData);

        Assert.Equal("No more data", cut.Find("[part='tip']").TextContent.Trim());
    }

    [Fact]
    public async Task FluentPullToRefresh_SetDistance_AppliesTransform_Down()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 20);

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Contains("translate3d(0, 20px, 0)", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_SetDistance_AppliesTransform_Up()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Direction, PullDirection.Up)
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 12);

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Contains("translate3d(0, -12px, 0)", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_SetDistance_ResetClearsTransform()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 18);
        await SetDistanceAsync(cut, -1);

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.DoesNotContain("translate3d", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_SetDistance_LessThanDragDistanceKeepsPulling()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.DragDistance, 40)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 20);

        Assert.Equal(PullStatus.Pulling, GetPullStatus(cut));
    }

    [Fact]
    public async Task FluentPullToRefresh_SetDistance_GreaterThanDragDistanceClampsAndWaitsForRelease()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.DragDistance, 30)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 70);

        Assert.Equal(PullStatus.WaitingForRelease, GetPullStatus(cut));
        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Contains("translate3d(0, 30px, 0)", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_DragThreshold_PreventsMovementUntilExceeded()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Direction, PullDirection.Up)
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.DragThreshold, 10)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var container = cut.Find("div.fluent-pull-container");
        await container.TriggerEventAsync("ontouchstart", CreateTouchEventArgs(100));
        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(95));

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.DoesNotContain("translate3d", wrapper.GetAttribute("style"));
        Assert.Equal(PullStatus.Pulling, GetPullStatus(cut));

        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(60));

        wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Contains("translate3d", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnTouchEnd_WithMoreData_CompletesThenResets()
    {
        var refreshCalls = 0;
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.StatusUpdateMessageTimeout, 10)
            .Add(p => p.OnRefreshAsync, () =>
            {
                refreshCalls++;
                return Task.FromResult(true);
            })
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 80);
        var container = cut.Find("div.fluent-pull-container");
        var touchEndTask = container.TriggerEventAsync("ontouchend", CreateTouchEventArgs(0));

        await cut.WaitForAssertionAsync(() => Assert.Equal(PullStatus.Completed, GetPullStatus(cut)));

        await touchEndTask;

        Assert.Equal(PullStatus.Awaiting, GetPullStatus(cut));
        Assert.Equal(1, refreshCalls);
        Assert.DoesNotContain("translate3d", cut.Find("div.fluent-pull-container > div").GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnTouchEnd_NoMoreData_ShowsNoDataBeforeReset()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.StatusUpdateMessageTimeout, 10)
            .Add(p => p.OnRefreshAsync, () => Task.FromResult(false))
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 80);
        var container = cut.Find("div.fluent-pull-container");
        var touchEndTask = container.TriggerEventAsync("ontouchend", CreateTouchEventArgs(0));

        await cut.WaitForAssertionAsync(() => Assert.Equal(PullStatus.NoData, GetPullStatus(cut)));

        await touchEndTask;

        Assert.Equal(PullStatus.Awaiting, GetPullStatus(cut));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnTouchMoveDown_AtTop_ClampsAndWaitsForRelease()
    {
        var module = JSInterop.SetupModule(matcher => matcher.Arguments.Any(arg => arg?.ToString()?.EndsWith("PullToRefresh/FluentPullToRefresh.razor.js") == true));
        module.Setup<int>("Microsoft.FluentUI.Blazor.PullToRefresh.GetScrollDistToTop").SetResult(0);
        module.SetupVoid("Microsoft.FluentUI.Blazor.PullToRefresh.InitTouchEmulator");

        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.DragDistance, 32)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var container = cut.Find("div.fluent-pull-container");
        await container.TriggerEventAsync("ontouchstart", CreateTouchEventArgs(100));
        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(200));

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Equal(PullStatus.WaitingForRelease, GetPullStatus(cut));
        Assert.Contains("translate3d(0, 32px, 0)", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnTouchMoveDown_WhenScrolled_ReturnsEarly()
    {
        var module = JSInterop.SetupModule(matcher => matcher.Arguments.Any(arg => arg?.ToString()?.EndsWith("PullToRefresh/FluentPullToRefresh.razor.js") == true));
        module.Setup<int>("Microsoft.FluentUI.Blazor.PullToRefresh.GetScrollDistToTop").SetResult(10);
        module.SetupVoid("Microsoft.FluentUI.Blazor.PullToRefresh.InitTouchEmulator");

        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.DragDistance, 32)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var container = cut.Find("div.fluent-pull-container");
        await container.TriggerEventAsync("ontouchstart", CreateTouchEventArgs(100));
        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(200));

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Equal(PullStatus.Pulling, GetPullStatus(cut));
        Assert.DoesNotContain("translate3d", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_Disabled_IgnoresTouchMovement()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Disabled, true)
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var container = cut.Find("div.fluent-pull-container");
        await container.TriggerEventAsync("ontouchstart", CreateTouchEventArgs(100));
        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(150));
        await container.TriggerEventAsync("ontouchend", CreateTouchEventArgs(150));

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Equal(PullStatus.Awaiting, GetPullStatus(cut));
        Assert.DoesNotContain("translate3d", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnRefreshAsyncThrows_ResetsAndPropagates()
    {
        var module = JSInterop.SetupModule(matcher => matcher.Arguments.Any(arg => arg?.ToString()?.EndsWith("PullToRefresh/FluentPullToRefresh.razor.js") == true));
        module.SetupVoid("Microsoft.FluentUI.Blazor.PullToRefresh.InitTouchEmulator");

        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.EmulateTouch, true)
            .Add(p => p.OnRefreshAsync, () => throw new InvalidOperationException("boom"))
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        await SetDistanceAsync(cut, 80);
        var container = cut.Find("div.fluent-pull-container");

        await Assert.ThrowsAsync<InvalidOperationException>(() => container.TriggerEventAsync("ontouchend", CreateTouchEventArgs(0)));

        var wrapper = cut.Find("div.fluent-pull-container > div");
        Assert.Equal(PullStatus.Awaiting, GetPullStatus(cut));
        Assert.DoesNotContain("translate3d", wrapper.GetAttribute("style"));
    }

    [Fact]
    public async Task FluentPullToRefresh_OnTouchEndWhilePulling_ResetsTipVisibility()
    {
        var cut = Render<FluentPullToRefresh>(parameters => parameters
            .Add(p => p.Direction, PullDirection.Up)
            .Add(p => p.ShowStaticTip, false)
            .Add(p => p.EmulateTouch, false)
            .Add(p => p.DragDistance, 30)
            .Add(p => p.ChildContent, builder => builder.AddContent(0, "Content")));

        var container = cut.Find("div.fluent-pull-container");
        await container.TriggerEventAsync("ontouchstart", CreateTouchEventArgs(100));
        await container.TriggerEventAsync("ontouchmove", CreateTouchEventArgs(95));

        Assert.NotEmpty(cut.FindAll("[part='tip']"));

        await container.TriggerEventAsync("ontouchend", CreateTouchEventArgs(95));

        Assert.Equal(PullStatus.Awaiting, GetPullStatus(cut));
        Assert.Empty(cut.FindAll("[part='tip']"));
    }

    private static void SetPullStatus(IRenderedComponent<FluentPullToRefresh> cut, PullStatus status)
    {
        var field = typeof(FluentPullToRefresh).GetField("_pullStatus", BindingFlags.Instance | BindingFlags.NonPublic);
        field!.SetValue(cut.Instance, status);
        cut.Render();
    }

    private static Task SetDistanceAsync(IRenderedComponent<FluentPullToRefresh> cut, int distance)
    {
        var method = typeof(FluentPullToRefresh).GetMethod("SetDistance", BindingFlags.Instance | BindingFlags.NonPublic);
        return cut.InvokeAsync(() => method!.Invoke(cut.Instance, [distance]));
    }

    private static PullStatus GetPullStatus(IRenderedComponent<FluentPullToRefresh> cut)
    {
        var field = typeof(FluentPullToRefresh).GetField("_pullStatus", BindingFlags.Instance | BindingFlags.NonPublic);
        return (PullStatus)field!.GetValue(cut.Instance)!;
    }

    private static TouchEventArgs CreateTouchEventArgs(double clientY)
    {
        return new TouchEventArgs
        {
            TargetTouches =
            [
                new TouchPoint
                {
                    ClientY = clientY,
                }
            ],
        };
    }

    private static RenderFragment SpanTemplate(string cssClass, string text) => builder =>
    {
        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", cssClass);
        builder.AddContent(2, text);
        builder.CloseElement();
    };
}

