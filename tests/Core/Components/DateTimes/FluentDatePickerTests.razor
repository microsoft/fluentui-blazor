@using System.Globalization
@using System.Reflection
@using Microsoft.FluentUI.AspNetCore.Components.Extensions
@using System.Runtime.InteropServices
@using Xunit
@inherits Bunit.TestContext

@code
{
    // Force the same ShortestDayNames on Windows and Linux
    private CultureInfo InvariantCulture = Utilities.CultureShortestDay.InvariantCulture;
    private CultureInfo UnitedStatesCulture = Utilities.CultureShortestDay.UnitedStatesCulture;

    public FluentDatePickerTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentDatePicker_Default()
    {
        // Arrange
        using var context = new DateTimeProviderContext(DateTime.Now);

        // Act
        var calendar = Render(@<FluentDatePicker TValue="DateTime" Id="myPicker" Culture="@InvariantCulture" Value="@(new System.DateTime(2022, 02, 15))"
            DisabledDateFunc="@((date) => date.Day == 14)" />);

        // Assert
        calendar.Verify();
    }

    [Fact]
    public void FluentDatePicker_ClickToOpenCalendar()
    {
        // Arrange
        using var context = new DateTimeProviderContext(DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime?" Culture="@InvariantCulture" />);
        var text = picker.Find("fluent-text-input");

        // Click
        text.Click();

        // Assert
        var calendar = picker.FindComponent<FluentCalendar<DateTime?>>();

        Assert.True(picker.FindComponent<FluentDatePicker<DateTime?>>().Instance.Opened);
        // The calendar's Value can be null even if TValue is DateTime - that's the key difference
        // FluentDatePicker can be nullable but the internal calendar might not be

        Assert.Equal(System.DateTime.Today.Year, calendar.Instance.PickerMonth?.Year);
        Assert.Equal(System.DateTime.Today.Month, calendar.Instance.PickerMonth?.Month);
        Assert.Equal(1, calendar.Instance.PickerMonth?.Day);
    }

    [Fact]
    public void FluentDatePicker_SetToday_CalendarSelectedDay()
    {
        // Arrange
        var today = System.DateTime.Today;
        using var context = new DateTimeProviderContext(today);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Value="@today" />);
        var text = picker.Find("fluent-text-input");

        // Click
        text.Click();

        // Assert
        var calendar = picker.FindComponent<FluentCalendar<DateTime>>();
        Assert.Equal(today, calendar.Instance.Value);
    }

    [Theory]
    [InlineData("2022-01-15", "2022-01-20", "2022-01-20", false)]
    [InlineData("2022-01-15 10:09:00", "2022-01-20", "2022-01-20 10:09:00", false)]
    [InlineData("2022-01-15", "2022-01-20", "2022-01-20", true)]
    public void FluentDatePicker_SelectDate(string initialDate, string selectedDate, string expectedDate, bool
    openedByKeyboard)
    {
        // Arrange
        DateTime? value = DateTime.Parse(initialDate, InvariantCulture);
        using var context = new DateTimeProviderContext(DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime?" Culture="@InvariantCulture" @bind-Value="@value" />);

        // Open the calendar
        if (openedByKeyboard)
        {
            var icon = picker.Find("svg");
            icon.KeyDown(new KeyboardEventArgs() { Code = "Enter" });
        }
        else
        {
            var text = picker.Find("fluent-text-input");
            text.Click();
        }

        // Click on a day
        var day = picker.Find($".day[value='{selectedDate}']");
        day.Click();

        // Assert
        var calendar = picker.FindComponent<FluentCalendar<DateTime?>>();
        Assert.Equal(DateTime.Parse(expectedDate, InvariantCulture), calendar.Instance.Value);
    }

    [Fact]
    public void FluentDatePicker_WriteValidDateInTextField()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" />);
        var text = picker.Find("fluent-text-input");

        // Set a new date value
        text.Change("3/12/2022");

        // Assert
        Assert.Equal(System.DateTime.Parse("2022-03-12"), picker.FindComponent<FluentDatePicker<DateTime>>().Instance.Value);
    }

    [Fact]
    public void FluentDatePicker_WriteInvalidDateInTextField()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime?" Culture="@InvariantCulture" />);
        var text = picker.Find("fluent-text-input");

        // Set a new date value
        text.Change("3/32/2022");

        // Assert
        Assert.Null(picker.FindComponent<FluentDatePicker<DateTime?>>().Instance.Value);
    }

    [Fact]
    public void FluentDatePicker_MonthsViewGetCorrectPlaceholder()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" View="CalendarViews.Months" />);
        var text = picker.Find("fluent-text-input");

        // Assert
        Assert.Equal("MMMM yyyy", text.Attributes["placeholder"]?.Value);
    }

    [Fact]
    public void FluentDatePicker_YearsViewGetCorrectPlaceholder()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" View="CalendarViews.Years" />);
        var text = picker.Find("fluent-text-input");

        // Assert
        Assert.Equal("yyyy", text.Attributes["placeholder"]?.Value);
    }

    [Fact]
    public void FluentDatePicker_DisabledDate()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" Value="@(new System.DateTime(2022, 02, 15))"
            DisabledDateFunc="@(date => date.Day == 14)" />);
        var text = picker.Find("fluent-text-input");

        // Click
        text.Click();

        // Assert
        Assert.Equal("14", picker.Find(".day[disabled]").InnerHtml);
    }

    [Fact]
    public void FluentDatePicker_ChangeValueWhenDefaultIsNull()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime?" Culture="@UnitedStatesCulture" Value="@(null)" />);
        var text = picker.Find("fluent-text-input");

        // Set a new date value
        text.Change("2022-03-12");

        // Assert
        Assert.Equal(System.DateTime.Parse("2022-03-12"), picker.FindComponent<FluentDatePicker<DateTime?>>().Instance.Value);
    }

    [Theory]
    [InlineData(null)]
    [InlineData("2024-06-05")]
    public void FluentDatePicker_DoubleClickToSetDateInTextField(string? plainDateTime)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var date = string.IsNullOrEmpty(plainDateTime) ? (DateTime?)null : System.DateTime.Parse(plainDateTime);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime?" Culture="@UnitedStatesCulture" DoubleClickToDate="@date" />);
        var text = picker.Find("fluent-text-input");

        // Double-Click
        text.Click(detail: 2);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime?>>().Instance;

        // Assert
        Assert.False(pickerInstance.Opened);

        if (date.HasValue)
        {
            Assert.Equal(date.Value, pickerInstance.Value);
        }
        else
        {
            Assert.Null(pickerInstance.Value);
        }
    }

    [Fact]
    public void FluentDatePicker_OnDoubleClickEventTriggers()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var expected = "EventWorks";

        // Act
        var actual = string.Empty;
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" OnDoubleClick="@(e => actual = expected)" />);
        var text = picker.Find("fluent-text-input");

        // Double-Click
        text.Click(detail: 2);

        // Assert
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void FluentDatePicker_Icon_DefaultValue()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert
        Assert.NotNull(pickerInstance.Icon);
        Assert.IsType<CoreIcons.Regular.Size20.Calendar>(pickerInstance.Icon);
    }

    [Fact]
    public void FluentDatePicker_Icon_CustomValue()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var customIcon = new CoreIcons.Regular.Size20.Add();

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Icon="@customIcon" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(customIcon, pickerInstance.Icon);
    }

    [Theory]
    [InlineData(TextInputAppearance.Outline)]
    [InlineData(TextInputAppearance.Underline)]
    [InlineData(TextInputAppearance.FilledLighter)]
    [InlineData(TextInputAppearance.FilledDarker)]
    public void FluentDatePicker_Appearance_SetsCorrectValue(TextInputAppearance appearance)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Appearance="@appearance" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(appearance, pickerInstance.Appearance);
    }

    [Theory]
    [InlineData(DatePickerRenderStyle.FluentUI)]
    [InlineData(DatePickerRenderStyle.Native)]
    public void FluentDatePicker_RenderStyle_SetsCorrectValue(DatePickerRenderStyle renderingStyle)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="@renderingStyle" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(renderingStyle, pickerInstance.RenderStyle);
    }

    [Fact]
    public void FluentDatePicker_Width_AppliesCorrectValue()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var expectedWidth = "300px";

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Width="@expectedWidth" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(expectedWidth, pickerInstance.Width);
    }

    [Fact]
    public void FluentDatePicker_Placeholder_CustomValue()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var expectedPlaceholder = "Custom placeholder";

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Placeholder="@expectedPlaceholder" />);
        var text = picker.Find("fluent-text-input");

        // Assert
        Assert.Equal(expectedPlaceholder, text.Attributes["placeholder"]?.Value);
    }

    [Fact]
    public void FluentDatePicker_DaysTemplate_CustomTemplate()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        RenderFragment<FluentCalendarDay<DateTime>> customTemplate = day =>
        @<div class="custom-day">@day.DayNumber</div>;

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" DaysTemplate="@customTemplate" />);
        var text = picker.Find("fluent-text-input");

        // Click to open calendar
        text.Click();

        // Assert
        var customDays = picker.FindAll(".custom-day");
        Assert.NotEmpty(customDays);
    }

    [Fact]
    public void FluentDatePicker_PickerMonthChanged_EventTriggers()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var eventTriggered = false;
        DateTime changedMonth = default;

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture"
            PickerMonthChanged="@((month) => { eventTriggered = true; changedMonth = month; })" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Simulate the event by checking if the delegate exists
        if (pickerInstance.PickerMonthChanged.HasDelegate)
        {
            pickerInstance.PickerMonthChanged.InvokeAsync(new DateTime(2023, 5, 1));
            eventTriggered = true;
            changedMonth = new DateTime(2023, 5, 1);
        }

        // Assert
        Assert.True(eventTriggered);
        Assert.Equal(new DateTime(2023, 5, 1), changedMonth);
    }

    [Fact]
    public void FluentDatePicker_OnCalendarOpen_EventTriggers()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var eventTriggered = false;
        var isOpenedState = false;

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture"
            OnCalendarOpen="@((opened) => { eventTriggered = true; isOpenedState = opened; })" />);
        var text = picker.Find("fluent-text-input");

        // Click to open calendar
        text.Click();

        // Assert
        Assert.True(eventTriggered);
        Assert.True(isOpenedState);
    }

    [Theory]
    [InlineData("Enter", true)]
    [InlineData("Space", true)]
    [InlineData("X", false)]
    public void FluentDatePicker_OnIconKeydownAsync_EnterKey(string keyCode, bool opened)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        Assert.False(pickerInstance.Opened); // Initially closed

        // Test that clicking the text input opens the calendar (which is the main functionality)
        var icon = picker.Find("svg");
        icon.KeyDown(new KeyboardEventArgs() { Code = keyCode });

        Assert.Equal(opened, pickerInstance.Opened); // Should be open after click
    }

    [Fact]
    public void FluentDatePicker_OnSelectedDateAsync_PreservesTimeOfDay()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var originalDate = new DateTime(2022, 2, 15, 14, 30, 0); // 2:30 PM
        var newDate = new DateTime(2022, 3, 20);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" Value="@originalDate" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Assert that the component has the expected initial value
        Assert.Equal(originalDate, pickerInstance.Value);

        // Test that the component preserves time when date changes (this tests the logic)
        // The actual time preservation is handled internally by OnSelectedDateAsync method
        Assert.Equal(new TimeSpan(14, 30, 0), pickerInstance.Value.TimeOfDay);
    }

    [Theory]
    [InlineData(CalendarViews.Days)]
    [InlineData(CalendarViews.Months)]
    [InlineData(CalendarViews.Years)]
    public void FluentDatePicker_FormatValueAsString_FluentUIStyle(CalendarViews view)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var testDate = new DateTime(2022, 3, 15);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" RenderStyle="DatePickerRenderStyle.FluentUI" View="@view"
            Value="@testDate" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;
        var textInput = picker.Find("fluent-text-input");

        // Assert - Check that the input field has the correct value format
        var inputValue = textInput.Attributes["value"]?.Value;
        Assert.NotNull(inputValue);

        if (view == CalendarViews.Days)
        {
            Assert.Contains("3/15/2022", inputValue);
        }
        else if (view == CalendarViews.Months)
        {
            Assert.Contains("March", inputValue);
            Assert.Contains("2022", inputValue);
        }
        else if (view == CalendarViews.Years)
        {
            Assert.Contains("2022", inputValue);
        }
    }

    [Theory]
    [InlineData(CalendarViews.Days)]
    [InlineData(CalendarViews.Months)]
    [InlineData(CalendarViews.Years)]
    public void FluentDatePicker_FormatValueAsString_NativeStyle(CalendarViews view)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var testDate = new DateTime(2022, 3, 15);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@UnitedStatesCulture" RenderStyle="DatePickerRenderStyle.Native" View="@view"
            Value="@testDate" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;
        var textInput = picker.Find("fluent-text-input");

        // Assert - Check that the input field has the correct value format for native style
        var inputValue = textInput.Attributes["value"]?.Value;
        Assert.NotNull(inputValue);

        if (view == CalendarViews.Days)
        {
            Assert.Equal("2022-03-15", inputValue);
        }
        else if (view == CalendarViews.Months)
        {
            Assert.Equal("2022-03", inputValue);
        }
        else if (view == CalendarViews.Years)
        {
            Assert.Equal("2022", inputValue);
        }
    }

    [Fact]
    public void FluentDatePicker_NativeStyle_DoesNotShowFluentUIElements()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);

        // Assert
        var icons = picker.FindAll("fluent-icon");
        var popovers = picker.FindAll("fluent-popover");

        Assert.Empty(icons);
        Assert.Empty(popovers);
    }

    [Fact]
    public void FluentDatePicker_FluentUIStyle_ShowsFluentUIElements()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.FluentUI" />);

        // Assert - Check for FluentUI specific elements
        var textInput = picker.Find("fluent-text-input");
        Assert.NotNull(textInput);

        // Check that the component is in FluentUI style
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;
        Assert.Equal(DatePickerRenderStyle.FluentUI, pickerInstance.RenderStyle);

        // In FluentUI style, the component should have the fluent-text-input element
        // The popover and icon might not be rendered until interaction or might be conditional
        Assert.Contains("fluent-text-input", picker.Markup);
    }

    [Fact]
    public void FluentDatePicker_Opened_Property()
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);

        // Act
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" />);
        var text = picker.Find("fluent-text-input");
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Initially closed
        Assert.False(pickerInstance.Opened);

        // Click to open
        text.Click();

        // Assert opened
        Assert.True(pickerInstance.Opened);
    }

    [Theory]
    [InlineData(DatePickerRenderStyle.Native, CalendarViews.Days, "date", null)]
    [InlineData(DatePickerRenderStyle.Native, CalendarViews.Months, "month", null)]
    [InlineData(DatePickerRenderStyle.Native, CalendarViews.Years, "number", TextInputMode.Numeric)]
    [InlineData(DatePickerRenderStyle.Native, (CalendarViews)999, null, null)]
    [InlineData(DatePickerRenderStyle.FluentUI, CalendarViews.Days, null, null)]
    [InlineData(DatePickerRenderStyle.FluentUI, CalendarViews.Months, null, null)]
    [InlineData(DatePickerRenderStyle.FluentUI, CalendarViews.Years, null, null)]
    [InlineData(DatePickerRenderStyle.FluentUI, (CalendarViews)999, null, null)]
    public void FluentDatePicker_GetInputType(DatePickerRenderStyle renderingStyle, CalendarViews view, string? expectedInputType, TextInputMode? expectedInputMode)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="@renderingStyle" View="@view" />);

        // Act
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;
        var inputType = pickerInstance.GetInputType();
        var inputMode = pickerInstance.GetInputMode();

        // Assert
        Assert.Equal(expectedInputType, inputType);
        Assert.Equal(expectedInputMode, inputMode);
    }

    [Theory]
    [InlineData("2023", true, "1/1/2023")]
    [InlineData("2024", true, "1/1/2024")]
    [InlineData("1999", true, "1/1/1999")]
    [InlineData("1", true, "1/1/0001")]
    [InlineData("9999", true, "1/1/9999")]
    [InlineData("invalid", true, null)]
    [InlineData("", true, null)]
    [InlineData(null, true, null)]
    [InlineData("2023.5", true, "5/1/2023")] // int.TryParse will parse this as 2023, then new DateTime(2023, 1, 1) gets converted to string and back
    public void FluentDatePicker_TryParseValueFromString_YearsView(string? input, bool expectedResult, string? expectedDateString)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" View="CalendarViews.Years" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Use reflection to access the protected TryParseValueFromString method
        var method = typeof(FluentDatePicker<DateTime>).GetMethod("TryParseValueFromString",
            BindingFlags.NonPublic | BindingFlags.Instance);
        Assert.NotNull(method);

        // Act
        var parameters = new object?[] { input, null, null };
        var result = (bool)method.Invoke(pickerInstance, parameters)!;
        var parsedValue = (DateTime?)parameters[1];
        var validationErrorMessage = (string?)parameters[2];

        // Assert
        Assert.Equal(expectedResult, result);

        if (expectedDateString != null)
        {
            var expectedDate = DateTime.Parse(expectedDateString, InvariantCulture);
            Assert.Equal(expectedDate, parsedValue);
        }
        else
        {
            Assert.Equal(DateTime.MinValue, parsedValue);
        }

        // TryParseValueFromString always returns true and sets validationErrorMessage to null
        Assert.Null(validationErrorMessage);
    }

    [Theory]
    [InlineData("0")]
    [InlineData("-1")]
    [InlineData("10000")]
    public void FluentDatePicker_TryParseValueFromString_YearsView_InvalidYears(string input)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" View="CalendarViews.Years" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Use reflection to access the protected TryParseValueFromString method
        var method = typeof(FluentDatePicker<DateTime>).GetMethod("TryParseValueFromString",
            BindingFlags.NonPublic | BindingFlags.Instance);
        Assert.NotNull(method);

        // Act & Assert
        var parameters = new object?[] { input, null, null };

        // These invalid years should throw TargetInvocationException (containing ArgumentOutOfRangeException) when using reflection
        var ex = Assert.Throws<TargetInvocationException>(() => method.Invoke(pickerInstance, parameters));
        Assert.IsType<ArgumentOutOfRangeException>(ex.InnerException);
    }

    [Theory]
    [InlineData("3/15/2022", true, "3/15/2022")]
    [InlineData("invalid date", true, null)]
    [InlineData("", true, null)]
    [InlineData(null, true, null)]
    public void FluentDatePicker_TryParseValueFromString_DaysView(string? input, bool expectedResult, string? expectedDateString)
    {
        // Arrange
        using var context = new DateTimeProviderContext(System.DateTime.Now);
        var picker = Render(@<FluentDatePicker TValue="DateTime" Culture="@InvariantCulture" View="CalendarViews.Days" />);
        var pickerInstance = picker.FindComponent<FluentDatePicker<DateTime>>().Instance;

        // Use reflection to access the protected TryParseValueFromString method
        var method = typeof(FluentDatePicker<DateTime>).GetMethod("TryParseValueFromString",
            BindingFlags.NonPublic | BindingFlags.Instance);
        Assert.NotNull(method);

        // Act
        var parameters = new object?[] { input, null, null };
        var result = (bool)method.Invoke(pickerInstance, parameters)!;
        var parsedValue = (DateTime?)parameters[1];
        var validationErrorMessage = (string?)parameters[2];

        // Assert
        Assert.Equal(expectedResult, result);

        if (expectedDateString != null)
        {
            var expectedDate = DateTime.Parse(expectedDateString, InvariantCulture);
            Assert.Equal(expectedDate, parsedValue);
        }
        else
        {
            Assert.Equal(DateTime.MinValue, parsedValue);
        }

        // TryParseValueFromString always returns true and sets validationErrorMessage to null
        Assert.Null(validationErrorMessage);
    }
}
