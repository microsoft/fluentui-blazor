@using System.Globalization
@using System.Reflection
@using Microsoft.FluentUI.AspNetCore.Components.Extensions
@using System.Runtime.InteropServices
@using Xunit
@inherits Bunit.TestContext

@code
{
    // Force the same ShortestDayNames on Windows and Linux
    private CultureInfo InvariantCulture = Utilities.CultureShortestDay.InvariantCulture;
    private CultureInfo UnitedStatesCulture = Utilities.CultureShortestDay.UnitedStatesCulture;

    public FluentTimePickerTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentTimePicker_Default()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker StartHour="8" EndHour="12" Increment="30" Culture="@InvariantCulture" Value="@(new DateTime(2023, 1, 1, 10, 30, 0))" />);

        // Assert
        timePicker.Verify();
    }

    [Fact]
    public void FluentTimePicker_DefaultValue_FluentUIStyle()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.FluentUI" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(DatePickerRenderStyle.FluentUI, timePickerInstance.RenderStyle);
        Assert.Equal(ListAppearance.Outline, timePickerInstance.Appearance);
        Assert.Equal(8, timePickerInstance.StartHour);
        Assert.Equal(18, timePickerInstance.EndHour);
        Assert.Equal(15, timePickerInstance.Increment);
    }

    [Fact]
    public void FluentTimePicker_DefaultValue_NativeStyle()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);

        // Assert
        timePicker.Verify();
    }

    [Theory]
    [InlineData(ListAppearance.Outline)]
    [InlineData(ListAppearance.FilledLighter)]
    [InlineData(ListAppearance.FilledDarker)]
    [InlineData(ListAppearance.Transparent)]
    public void FluentTimePicker_Appearance_SetsCorrectValue(ListAppearance appearance)
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Appearance="@appearance" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(appearance, timePickerInstance.Appearance);
    }

    [Theory]
    [InlineData(DatePickerRenderStyle.FluentUI)]
    [InlineData(DatePickerRenderStyle.Native)]
    public void FluentTimePicker_RenderStyle_SetsCorrectValue(DatePickerRenderStyle renderStyle)
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="@renderStyle" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(renderStyle, timePickerInstance.RenderStyle);
    }

    [Fact]
    public void FluentTimePicker_Width_AppliesCorrectValue()
    {
        // Arrange
        var expectedWidth = "250px";

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Width="@expectedWidth" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(expectedWidth, timePickerInstance.Width);
    }

    [Fact]
    public void FluentTimePicker_Placeholder_CustomValue()
    {
        // Arrange
        var expectedPlaceholder = "Select time";

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Placeholder="@expectedPlaceholder" RenderStyle="DatePickerRenderStyle.FluentUI" />);
        var dropdown = timePicker.Find("fluent-dropdown");

        // Assert
        Assert.Equal(expectedPlaceholder, dropdown.GetAttribute("placeholder"));
    }

    [Fact]
    public void FluentTimePicker_Placeholder_DefaultValue()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@UnitedStatesCulture" RenderStyle="DatePickerRenderStyle.FluentUI" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert - Should use the culture's short time pattern as placeholder
        Assert.Contains("h:mm", timePickerInstance.Culture.DateTimeFormat.ShortTimePattern.ToLower());
    }

    [Theory]
    [InlineData(6, 22, 30)]
    [InlineData(9, 17, 15)]
    [InlineData(0, 23, 60)]
    public void FluentTimePicker_StartEndHourAndIncrement_GeneratesCorrectItems(int startHour, int endHour, int increment)
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" StartHour="@startHour" EndHour="@endHour" Increment="@increment" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(startHour, timePickerInstance.StartHour);
        Assert.Equal(endHour, timePickerInstance.EndHour);
        Assert.Equal(increment, timePickerInstance.Increment);
    }

    [Fact]
    public void FluentTimePicker_DisabledTimeFunc_DisablesSpecificTimes()
    {
        // Arrange
        Func<DateTime, bool> disableFunc = time => time.Hour == 12; // Disable noon

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" DisabledTimeFunc="@disableFunc" StartHour="10" EndHour="14" Increment="60" />);

        // Assert - Component should have the disabled function
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;
        Assert.NotNull(timePickerInstance.DisabledTimeFunc);
    }

    [Theory]
    [InlineData("14:30:00")]
    [InlineData("09:15:30")]
    [InlineData("23:59:59")]
    public void FluentTimePicker_FormatValueAsString_DateTime(string timeString)
    {
        // Arrange
        var testTime = DateTime.Parse($"2023-01-01 {timeString}");

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Value="@testTime" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(testTime, timePickerInstance.Value);
    }

    [Theory]
    [InlineData("14:30")]
    [InlineData("09:15")]
    [InlineData("23:59")]
    public void FluentTimePicker_TryParseValueFromString_ValidTime(string timeString)
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime ?" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);
        var textInput = timePicker.Find("fluent-text-input");

        // Set time value
        textInput.Change(timeString);

        // Assert
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime?>>().Instance;
        Assert.NotNull(timePickerInstance.Value);

        var expectedTime = DateTime.ParseExact($"1900-01-01 {timeString}:00", "yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture);
        Assert.Equal(expectedTime.TimeOfDay, timePickerInstance.Value.Value.TimeOfDay);
    }

    [Fact]
    public void FluentTimePicker_TryParseValueFromString_InvalidTime()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime ?" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);
        var textInput = timePicker.Find("fluent-text-input");

        // Set invalid time value
        textInput.Change("25:70");

        // Assert
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime?>>().Instance;
        Assert.Null(timePickerInstance.Value);
    }

    [Fact]
    public void FluentTimePicker_FluentUIStyle_ShowsDropdown()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.FluentUI" />);

        // Assert
        var dropdown = timePicker.Find("fluent-dropdown");
        Assert.NotNull(dropdown);

        // Should not have FluentTextInput with type="time"
        var textInputs = timePicker.FindAll("fluent-text-input");
        var timeInputs = textInputs.Where(ti => ti.GetAttribute("type") == "time");
        Assert.Empty(timeInputs);
    }

    [Fact]
    public void FluentTimePicker_NativeStyle_ShowsTextInputWithTimeType()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);

        // Assert
        var textInput = timePicker.Find("fluent-text-input");
        Assert.NotNull(textInput);
        Assert.Equal("time", textInput.GetAttribute("type"));

        // Should not have FluentCombobox
        var comboboxes = timePicker.FindAll("fluent-combobox");
        Assert.Empty(comboboxes);
    }

    [Theory]
    [InlineData(typeof(DateTime))]
    [InlineData(typeof(DateTime?))]
    [InlineData(typeof(TimeOnly))]
    [InlineData(typeof(TimeOnly?))]
    public void FluentTimePicker_SupportedTypes_DoesNotThrowException(Type timeType)
    {
        // Arrange & Act
        var picker = timeType switch
        {
            Type t when t == typeof(DateTime)
                => Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" />),

            Type t when t == typeof(DateTime?)
                => Render(@<FluentTimePicker TValue="DateTime?" Culture="@InvariantCulture" />),

            Type t when t == typeof(TimeOnly)
                => Render(@<FluentTimePicker TValue="TimeOnly" Culture="@InvariantCulture" />),

            Type t when t == typeof(TimeOnly?)
                => Render(@<FluentTimePicker TValue="TimeOnly?" Culture="@InvariantCulture" />),

            _ => throw new NotSupportedException($"Type {timeType} is not supported.")
        };

        // Assert
        Assert.NotNull(picker);
    }

    [Fact]
    public void FluentTimePicker_InvalidSupportedTypes_ThrowException()
    {
        // Arrange & Act
        var exception = Assert.Throws<InvalidOperationException>(() =>
        {
            Render(@<FluentTimePicker TValue="string" Culture="@InvariantCulture" />);
        });

        Assert.Contains("The type parameter System.String is not supported", exception.Message);
        Assert.Contains("Supported types are DateTime, DateTime?, TimeOnly, and TimeOnly?", exception.Message);
    }

    [Fact]
    public void FluentTimePicker_Required_ShowsRequiredValidation()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime ?" Culture="@InvariantCulture" Required="true" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime?>>().Instance;

        // Assert
        Assert.True(timePickerInstance.Required);
    }

    [Fact]
    public void FluentTimePicker_ReadOnly_SetsCorrectValue()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" ReadOnly="true" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.True(timePickerInstance.ReadOnly);
    }

    [Fact]
    public void FluentTimePicker_Disabled_SetsCorrectValue()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Disabled="true" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.True(timePickerInstance.Disabled);
    }

    [Fact]
    public void FluentTimePicker_Label_SetsCorrectValue()
    {
        // Arrange
        var expectedLabel = "Select Time";

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Label="@expectedLabel" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(expectedLabel, timePickerInstance.Label);
    }

    [Fact]
    public void FluentTimePicker_Culture_SetsCorrectValue()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@UnitedStatesCulture" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(UnitedStatesCulture, timePickerInstance.Culture);
    }

    [Fact]
    public void FluentTimePicker_BindValue_UpdatesCorrectly()
    {
        // Arrange
        var initialTime = new DateTime(2023, 1, 1, 10, 30, 0);
        var timeValue = initialTime;

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" @bind-Value="@timeValue" />);
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        Assert.Equal(initialTime, timePickerInstance.Value);
    }

    [Fact]
    public void FluentTimePicker_KeyDownHandler_DeleteKey_ClearsValue()
    {
        // Arrange
        var initialTime = new DateTime(2023, 1, 1, 14, 30, 0);

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime ?" Culture="@InvariantCulture" Value="@initialTime" RenderStyle="DatePickerRenderStyle.FluentUI" />);
        var dropdown = timePicker.Find("fluent-dropdown");

        // Simulate Delete key press
        dropdown.KeyDown("Delete");

        // Assert
        var timePickerInstance = timePicker.FindComponent<FluentTimePicker<DateTime?>>().Instance;
        // The component should handle the delete key (though we can't easily test the clear operation in this context)
        Assert.NotNull(timePickerInstance);
    }

    [Theory]
    [InlineData(ListAppearance.FilledLighter, TextInputAppearance.FilledLighter)]
    [InlineData(ListAppearance.FilledDarker, TextInputAppearance.FilledDarker)]
    [InlineData(ListAppearance.Outline, TextInputAppearance.Outline)]
    [InlineData(ListAppearance.Transparent, TextInputAppearance.Underline)]
    [InlineData((ListAppearance)999, TextInputAppearance.Outline)]
    public void FluentTimePicker_TextInputAppearance_MapsCorrectly(ListAppearance listAppearance, TextInputAppearance expected)
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Appearance="@listAppearance" RenderStyle="DatePickerRenderStyle.Native" />);
        var textInput = timePicker.Find("fluent-text-input");

        var timePickerInstance = timePicker.FindComponent<FluentTextInput>().Instance;
        Assert.Equal(expected, timePickerInstance.Appearance);
    }

    [Fact]
    public void FluentTimePicker_DefaultCssClass_IsApplied()
    {
        // Arrange & Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" />);

        // Assert - Verify the component renders with the expected class in the markup
        Assert.Contains("fluent-timepicker", timePicker.Markup);
    }

    [Fact]
    public void FluentTimePicker_CustomClass_IsApplied()
    {
        // Arrange
        var customClass = "my-custom-class";

        // Act
        var timePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" Class="@customClass" />);

        // Assert - Verify both default and custom classes are in the markup
        Assert.Contains("fluent-timepicker", timePicker.Markup);
        Assert.Contains(customClass, timePicker.Markup);
    }

    [Fact]
    public void FluentTimePicker_GetInputType_ReturnsCorrectValue()
    {
        // Arrange & Act
        var fluentUITimePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.FluentUI" />);
        var nativeTimePicker = Render(@<FluentTimePicker TValue="DateTime" Culture="@InvariantCulture" RenderStyle="DatePickerRenderStyle.Native" />);

        var fluentUIInstance = fluentUITimePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;
        var nativeInstance = nativeTimePicker.FindComponent<FluentTimePicker<DateTime>>().Instance;

        // Assert
        // GetInputType is internal, but we can verify the render styles
        Assert.Equal(DatePickerRenderStyle.FluentUI, fluentUIInstance.RenderStyle);
        Assert.Equal(DatePickerRenderStyle.Native, nativeInstance.RenderStyle);
    }
}
