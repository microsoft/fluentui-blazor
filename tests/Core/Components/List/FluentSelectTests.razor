@using Microsoft.FluentUI.AspNetCore.Components.Utilities
@using Xunit;
@using Microsoft.FluentUI.AspNetCore.Components.Tests.Samples;
@inherits FluentUITestContext
@code
{
    private readonly IEnumerable<string?> Digits = new[] { null, "One", "Two", "Three" };

    private enum MyDigitsEnum
    {
        One,
        Two,
        Three
    }

    public FluentSelectTests()
    {
        JSInterop.Mode = JSRuntimeMode.Loose;
        Services.AddFluentUIComponents();
    }

    [Fact]
    public void FluentSelect_Default()
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect Placeholder="Select a digit" Items="@Digits" TOption="string" TValue="string" />);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentSelect_Label()
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect Label="List of digits" Required="true" Items="@Digits" TOption="string" TValue="string" />);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentSelect_Manual()
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect TOption="string" TValue="string">
    <FluentOptionString Value="One">One</FluentOptionString>
    <FluentOptionString Value="Two">Two</FluentOptionString>
    <FluentOptionString Value="Three">Three</FluentOptionString>
</FluentSelect>
    );

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentSelect_Template()
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect Items="@Digits" TOption="string" TValue="string">
            <OptionTemplate>
                @if (!String.IsNullOrEmpty(context))
                {
                    <span>[</span>
                    @context
                    <span>]</span>
                }
            </OptionTemplate>
        </FluentSelect>);

        // Assert
        var two = cut.Find("fluent-option[value='Two']");
        Assert.Equal("[Two]", two.GetInnerText());
    }

    [Fact]
    public void FluentSelect_Enum()
    {
        MyDigitsEnum selectedColor = MyDigitsEnum.One;

        // Arrange and Act
        var cut = Render(@<FluentSelect Items="@GetEnumValues()" @bind-Value="@selectedColor" />);

        // Assert
        cut.Verify();

        // Local function
        IEnumerable<MyDigitsEnum> GetEnumValues() => Enum.GetValues(typeof(MyDigitsEnum)).Cast<MyDigitsEnum>();
    }

    [Fact]
    public void FluentSelect_OptionFunctions()
    {
        // Arrange && Act
        //  - Disable the "Two" option
        //  - Uppercase the text
        //  - Add a prefix to the value
        //  - Select the "One" option
        var cut = Render(@<FluentSelect Items="@Digits"
                      OptionDisabled="@(item => item == "Two")"
                      OptionText="@(item => item?.ToUpper())"
                      OptionValue="@(item => $"value-{item}")" />);

        // Assert
        cut.Verify();
    }

    [Fact]
    public void FluentSelect_Default_InitialSelection()
    {
        string? value = "Two";

        // Arrange and Act
        var cut = Render(@<FluentSelect Items="@Digits" Value="@value" />);
        var two = cut.Find("fluent-option[value='Two']");

        // Assert
        Assert.True(two.HasAttribute("selected"));
    }

    [Fact]
    public void FluentSelect_Binding_InitialSelection()
    {
        string? value = "Two";

        // Arrange and Act
        var cut = Render(@<FluentSelect Items="@Digits" @bind-Value="@value" />);
        var two = cut.Find("fluent-option[value='Two']");

        // Assert
        Assert.True(two.HasAttribute("selected"));
    }

    [Fact]
    public void FluentSelect_Binding_Updated()
    {
        string? value = "Two";

        // Arrange
        var cut = Render(@<FluentSelect Items="@Digits" @bind-Value="@value" />);

        // Act and re-render
        cut.FindComponent<FluentSelect<string, string>>().Render(parameters => parameters.Add(p => p.Value, "One"));
        var one = cut.Find("fluent-option[value='One']");

        // Assert
        Assert.True(one.HasAttribute("selected"));
    }

    [Fact]
    public async Task FluentSelect_Multiple()
    {
        string value = "One";
        IEnumerable<string> selectedItems = ["One",];

        // Arrange
        var cut = Render(@<FluentSelect Multiple="true" Items="@Digits" @bind-Value="@value" @bind-SelectedItems="@selectedItems" />);
        var ids = cut.FindAll("fluent-option")
                     .Where(i => i.GetAttribute("value") == "One" || i.GetAttribute("value") == "Two")
                     .Select(i => i.GetAttribute("id"));

        // Act
        await cut.FindComponent<FluentSelect<string?, string>>().Instance.OnDropdownChangeHandlerAsync(new DropdownEventArgs
        {
            SelectedOptions = string.Join(';', ids),
        });

        // Assert
        Assert.Equal("One", value);
        Assert.Equal(new[] { "One", "Two" }, selectedItems);
    }

    [Theory]
    [InlineData("")]
    [InlineData(null)]
    [InlineData("InvalidId1;InvalidId2")]
    [InlineData("InvalidId1;    InvalidId2")]
    [InlineData("InvalidId1")]
    public async Task FluentSelect_Multiple_Unselect(string? selectedOptions)
    {
        string? value = "One";
        IEnumerable<string>? selectedItems = ["One",];

        // Arrange
        var cut = Render(@<FluentSelect Id="MyList" Multiple="true" Items="@Digits" @bind-Value="@value" @bind-SelectedItems="@selectedItems" />);

        // Act
        await cut.FindComponent<FluentSelect<string?, string?>>().Instance.OnDropdownChangeHandlerAsync(new DropdownEventArgs
        {
            Id = "MyList",
            Type = "",
            SelectedOptions = selectedOptions,
        });

        // Assert
        Assert.Null(value);
        Assert.Empty(selectedItems);
    }

    [Fact]
    public async Task FluentSelect_Multiple_OptionSelectedComparer()
    {
        string? value = "One";
        IEnumerable<string>? selectedItems = ["One",];

        // Arrange
        var cut = Render(@<FluentSelect
            Id="MyList"
            Multiple="true"
            Items="@Digits"
            OptionSelectedComparer="@((i, j) => string.Compare(i, j, StringComparison.InvariantCultureIgnoreCase) == 0)"
            @bind-Value="@value"
            @bind-SelectedItems="@selectedItems" />);

        // Act
        await cut.FindComponent<FluentSelect<string?, string?>>().Instance.OnDropdownChangeHandlerAsync(new DropdownEventArgs
        {
            Id = "MyList",
            Type = "",
            SelectedOptions = "ONE",    // Upper case to validate the "Ignore case"
        });

        // Assert
        Assert.Null(value);
        Assert.Empty(selectedItems);
    }

    [Fact]
    public void FluentSelect_Data()
    {
        // Arrange
        var myData = "MyData";
        var cut = Render(@<FluentSelect Items="@Digits" Data="@myData" TOption="string" TValue="string" />);

        // Assert
        var component = cut.FindComponent<FluentSelect<string, string>>();
        Assert.Equal("MyData", component.Instance.Data);
    }

    [Fact]
    public async Task FluentSelect_Option_Clicked()
    {
        string? value = "One";

        // Arrange
        var cut = Render(@<FluentSelect Items="@Digits" @bind-Value="@value" />);
        var ids = cut.FindAll("fluent-option")
                     .Where(i => i.GetAttribute("value") == "Two")
                     .Select(i => i.GetAttribute("id"));

        // Act
        await cut.FindComponent<FluentSelect<string?, string?>>().Instance.OnDropdownChangeHandlerAsync(new DropdownEventArgs
        {
            SelectedOptions = string.Join(';', ids),
        });

        // Assert
        Assert.Equal("Two", value);
    }

    [Theory]
    [InlineData(ListAppearance.Outline, null)]
    [InlineData(ListAppearance.FilledLighter, "filled-lighter")]
    [InlineData(ListAppearance.FilledDarker, "filled-darker")]
    [InlineData(ListAppearance.Transparent, "transparent")]
    [InlineData((ListAppearance)999, null)]
    [InlineData(null, null)]
    public void FluentSelect_Appearance(ListAppearance? appearance, string? expected)
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect Appearance="@appearance" Items="@Digits" TOption="string" TValue="string" />);
        var attribute = cut.Find("fluent-dropdown").GetAttribute("appearance");

        // Assert
        Assert.Equal(expected, attribute);
    }

    [Theory]
    [InlineData(ListSize.Medium, null)]
    [InlineData(ListSize.Large, "large")]
    [InlineData(ListSize.Small, "small")]
    [InlineData((ListSize)999, null)]
    [InlineData(null, null)]
    public void FluentSelect_Size(ListSize? size, string? expected)
    {
        // Arrange and Act
        var cut = Render(@<FluentSelect Size="@size" Items="@Digits" TOption="string" TValue="string" />);
        var attribute = cut.Find("fluent-dropdown").GetAttribute("size");

        // Assert
        Assert.Equal(expected, attribute);
    }

    [Theory]
    [InlineData("1", 1, null)]
    [InlineData("abc", 0, "The 'Unknown Bound Field' field is not valid.")]
    public void FluentSelect_TryParseValueFromString(string? value, int? expectedParsedValue, string? expectedValidationErrorMessage)
    {
        // Arrange
        var fluentSelect = new FluentSelect<int, int>(LibraryConfiguration.Empty);

        // Act
        fluentSelect.InternalTryParseValueFromString(value, out var parsedValue, out var validationErrorMessage);

        // Assert
        Assert.Equal(expectedParsedValue, parsedValue);
        Assert.Equal(expectedValidationErrorMessage, validationErrorMessage);
    }

    [Fact]
    public async Task FluentSelect_ClearAsync()
    {
        var value = "Two";
        IEnumerable<string> selectedItems = ["Two"];
        IEnumerable<string>? capturedSelectedItems = null;
        var selectedItemsChangedCalled = false;

        // Arrange
        var cut = Render(@<FluentSelect
            TOption="string"
            TValue="string"
            Items="@Digits"
            Value="@value" 
            SelectedItems="@selectedItems"
            SelectedItemsChanged="@(items => { capturedSelectedItems = items; selectedItemsChangedCalled = true; })" />);

        // Verify initial state
        var two = cut.Find("fluent-option[value='Two']");
        Assert.True(two.HasAttribute("selected"));
        Assert.Equal(new[] { "Two" }, selectedItems);

        // Act
        await cut.FindComponent<FluentSelect<string?, string?>>().Instance.ClearAsync();

        // Assert
        Assert.True(selectedItemsChangedCalled, "SelectedItemsChanged should have been invoked");
        Assert.NotNull(capturedSelectedItems);
        Assert.Empty(capturedSelectedItems);
    }

    [Fact]
    public async Task FluentSelect_ClearAsync_Multiple()
    {
        var value = "One";
        IEnumerable<string>? selectedItems = ["One", "Two"];
        IEnumerable<string>? capturedSelectedItems = null;
        var selectedItemsChangedCalled = false;

        // Arrange
        var cut = Render(@<FluentSelect
            TOption="string"
            TValue="string"
            Multiple="true"
            Items="@Digits" 
            Value="@value" 
            SelectedItems="@selectedItems"
            SelectedItemsChanged="@(items => { capturedSelectedItems = items; selectedItemsChangedCalled = true; })" />);

        // Verify initial state
        Assert.Equal(new[] { "One", "Two" }, selectedItems);

        // Act
        await cut.FindComponent<FluentSelect<string?, string?>>().Instance.ClearAsync();

        // Assert
        Assert.True(selectedItemsChangedCalled, "SelectedItemsChanged should have been invoked");
        Assert.NotNull(capturedSelectedItems);
        Assert.Empty(capturedSelectedItems);
    }
}
